\section{Implementation}
As a starting point, we take the third version of the reference implementation\footnote{\href{https://pqc-hqc.org/download.php?file=hqc-reference-implementation\_2021-06-06.zip}{https://pqc-hqc.org/download.php?file=hqc-reference-implementation\_2021-06-06.zip}}; this is a self-contained C implementation that can be ported on virtually any architecture as-is.

\subsection*{\textbf{Target}}
Our target architecture is \texttt{ARMv7E}: in particular, our tests are run on the STM F401-RE board mounting a Cortex\textsuperscript{\textregistered} M4 processor. This particular board is equipped with 512KB of flash memory and 96KB of RAM: due to this characteristics and the large memory footprint of the cryptosystem, we were able to run HQC only at security level 1 (corresponding to 128 bits of security).
In order to interact with the system we employ the Hardware Abstraction Layer (HAL) drivers, generated by STM32CubeMX specifically for our configuration. We use the drivers to notify when the encryption process is taking place through the LED on the board and to allow communications over the USB debug interface, redirecting in the \texttt{syscalls.c} file the standard output to the debug bridge for logging purposes.
To generate random variables required we employ the \texttt{seedexpander} function from SHAKE256~\cite{dworkin2015sha}.

\subsubsection*{\textbf{Objects representations}}
Elements of the various binary fields are represented as arrays. For randomly generated values, we employ the \texttt{seedexpander} function on a 40B seed.\\
The secret key \textsf{sk} = $(\mathbf{x}, \mathbf{y})$ is generated by $\mathbf{seed1}$, while the parity matrix $\mathbf{h}$ of the public key \textsf{pk}=$(\mathbf{h}, \mathbf{s})$ is generated by $\mathbf{seed2}$; the same principle applies for the random masks employed in the \texttt{safe\_mul} function. These values are sampled uniformly from the respective fields, with a given Hamming weight.\\
In all the multiplications, one of the operands is always a sparse polynomial: these polynomials are represented with a position vector of $\omega$ coordinates, containing the orders of the nonzero coefficients.

\subsubsection*{\textbf{Multiplication and masking}}
The multiplication over $\mathds{F}_2[X]/(X^n-1)$ is implemented with a slight variation of the scoolbook multiplication algorithm, since the sparsity of one of the operands yields a lower computational complexity than other methods.
This approach leaks information about the operands, which should remain secret: to overcome this problem we implemented a first-order masked multiplication scheme.\\

The dense ($a$) and sparse ($b$) polynomials are split in two halves, which are then combined accordingly to the ISW scheme; the \texttt{add} and \texttt{mult} function are an abstraction of the instructions that perform the addition and multiplication.

\begin{algorithm}
    \SetAlgoLined
    \SetKwFunction{secure_mult}{secure_mult}
    \KwIn{$a = (a_0a_1) \in \mathds{F}_2^n$ dense polynomial, $b = (b_0b_1)$ sparse polynomial, $\omega(b) = w$}
    \KwOut{$res, mask$ such that $res\oplus mask = a\cdot b$}
    \KwData{$temp_1, temp_2 \in \mathds{F}_2^n$}
    \SetKwProg{Fn}{function}{:}{}
    \BlankLine
    \BlankLine

    $mask \xleftarrow{\mathdollar_w} \mathds{F}_2^n$\\

    $temp_1 \leftarrow \texttt{mult}(a_1, b_0)$\\
    $temp_2 \leftarrow \texttt{mult}(a_0, b_1$)\\

    $res \leftarrow \texttt{add}(mask, temp_1)$\\
    $res \leftarrow \texttt{add}(res, temp_2)$\\

    $temp_1 \leftarrow \texttt{mult}(a_1, b_1)$\\
    $temp_2 \leftarrow \texttt{mult}(a_0, b_0$)\\

    $res \leftarrow \texttt{add}(res, temp_2)$\\
    $mask \leftarrow \texttt{add}(mask, temp_1)$\\

    \Return$res$, $mask$    
    \caption{First-order masked multiplication, 2 shares}
\end{algorithm}

We then generalized the masking procedure any number of by creating a small code generator to unroll the loops and reduce the execution time. 
We implemented and tested the masking procedure for $d \in \lbrace 2, 3, 4\rbrace$, as the number of operations grows with $\mathcal{O}(d^2)$.