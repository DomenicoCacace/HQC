\section{Cryptosystem Overview}
 Hamming Quasi-Cyclic (HQC) is a cryptosystem running for standardization to NIST's competition in the category ``post-quantum public key encryption scheme''~\cite{melchor2018hamming}.
It is a code-based cryptosystem, and its security is based on the hardness of a variant of the Decisional SD Problem, reported in~\cite{aguilar2018efficient}.\\
In order to cope with the huge key sizes associated with code-based cryptosystems, HQC adopts Quasi-Cyclic (QC) codes~\cite{gaborit2005shorter}; there is no general complexity result for the decoding of QC codes, but this problem is considered hard by the community.\\

HQC consists of two schemes: a Public Key Encryption (PKE) and a Key Encapsulation/Data Encapsulation Mechanism (KEM/DEM).

\subsubsection*{\textbf{\textsf{HQC.PKE}}}
The PKE employs a decodable $[n, k]$ code $\mathcal{C}$ generated by $\mathbf{G}\in \mathds{F}_2^{k\times n}$, which can correct at most $\delta$ errors with the $\mathcal{C}$.\textsf{Decode}($\cdot$) algorithm, and a random double-circulant $[2n, n]$ code with parity-check matrix $(\mathbf{1}, \mathbf{h})$; the algorithms that constitute this scheme are the following:

\begin{itemize}
  \item \textsf{Setup}(): generate and returns the parameters \textsf{param}=($n, k, \delta, w, w_{\mathbf{r}}, w_{\mathbf{e}}$).
  \item \textsf{KeyGen}(\textsf{param}): sample a random vector $\mathbf{h}$ for the parity-check matrix, the generator matrix $\mathbf{G}$ (which is public), the private key \textsf{pk} as a couple of random vectors $(\mathbf{x}, \mathbf{y}) \in \mathcal{R}^2$ both oh Hamming weight equal to $w$, then set the public key \textsf{pk} = ($\mathbf{h}$, $\mathbf{s} \leftarrow \mathbf{x}+\mathbf{h\cdot y}$); return the keys (\textsf{pk}, \textsf{sk}).
  \item \textsf{Encrypt}(\textsf{pk}, $\mathbf{m}$): generate the random vectors\\ $\mathbf{e} \in \mathcal{R}$, $(\mathbf{r}_1, \mathbf{r}_2) \in \mathcal{R}^2$ such that $\omega(\mathbf{e}) = w_{\mathbf{e}}$ and $\omega(\mathbf{r}_1) = \omega(\mathbf{r}_2) = w_{\mathbf{r}}$, then calculate the ciphertext as $\mathbf{c} = (\mathbf{u}, \mathbf{v}) = (\mathbf{r}_1 + \mathbf{h}\cdot\mathbf{r}_2, \mathbf{mG} + \mathbf{s}\cdot\mathbf{r}_2 + \mathbf{e})$
  \item \textsf{Decrypt}(\textsf{sk}, $\mathbf{c}$): return $\mathcal{C}$.\textsf{Decode}($\mathbf{v} - \mathbf{u\cdot y}$)
\end{itemize}
 
Although \textsf{sk} is composed of two vectors, $\mathbf{x}$ is only used to compute part of \textsf{pk} and it is not employed in the decryption phase.

\subsubsection*{\textbf{\textsf{HQC.KEM}}}
The KEM is built upon an instance of \textsf{HQC.PKE} $\mathcal{E}$ and three hash functions $\mathcal{G}, \mathcal{H}, \mathcal{K}$, with $\mathcal{G} \neq \mathcal{H}$.
The setup and key generation algorithms are the same of the PKE, with the exception that $k$ now is the lenght of the shared key.
\begin{itemize}
  \item \textsf{Encaps}(\textsf{pk}): generate a random $\mathbf{m} \in \mathds{F}_2^k$ to derive the randomness $\theta \leftarrow \mathcal{G}(\mathbf{m})$; 
  generate the ciphertext $\mathbf{c} \leftarrow \mathcal{E}.\textsf{Encrypt}(\textsf{pk}, \mathbf{m}, \theta)$, derive the symmetric key $K \leftarrow \mathcal{K}(\mathbf{m}, \mathbf{c})$
    and send $(\mathbf{c}, \mathbf{d} = \mathcal{H}(\mathbf{m}))$
  \item \textsf{Decaps}(\textsf{sk}, $\mathbf{c}$, $\mathbf{d}$): decrypt $\mathbf{\bar{m}} \leftarrow \mathcal{E}.\textsf{Decrypt}(\textsf{sk}, \mathbf{c})$, compute $\bar{\theta} \leftarrow \mathcal{G}(\mathbf{\bar{m}})$ and use them to calculate 
  $\mathbf{\bar{c}} \leftarrow \mathcal{E}(\textsf{pk}, \mathbf{\bar{m}}, \bar{\theta})$: at this point if both $\mathbf{c} = \mathbf{\bar{c}}$ and $\mathbf{d} = \mathcal{H}(\mathbf{\bar{m}})$
    we can derive the shared key $K \leftarrow \mathcal{K}(\mathbf{\bar{m}}, \mathbf{\bar{c}})$. 
\end{itemize}
