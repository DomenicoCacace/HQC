
\section{Hamming Quasi-Cyclic}
\begin{frame}
    \sectionpage
\end{frame}

\begin{frame}{Overview}
    \begin{block}{HQC}
        One of the third round alternative candidates
        \begin{itemize}
            \item IND-CPA Public Key Encryption
            \item IND-CCA2 Key Encapsulation Mechanism
            \item Based on a variant of the syndrome decoding problem
            \item Employs quasi-cyclic codes to shorten key sizes
        \end{itemize}
    \end{block}
    \begin{block}{Codes}
        HQC employs two codes:
        \begin{itemize}
            \item a decodable $\mathcal{C} [n, k]$ generated by $\mathbf{G}\in \mathds{F}_{2}^{k\times n}$ (public) 
            \item a random $[2n, n]$ code with parity-check matrix $\mathbf{H} = (\mathbf{I}_n | \mathbf{circ(h)})$
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Public Key Encryption}
    \begin{block}{Setup}
        Generate the parameters $(n, k, \delta, w, w_r, w_e)$ for the corresponding security level $\lambda$
    \end{block}
    \begin{block}{Key Generation}
        \begin{itemize}
            \item Generate $seed_h \xleftarrow{\$} \lbrace 0, 1 \rbrace^\lambda$
            \item Generate $\mathbf{h} \xleftarrow{\text{\sc PRNG}(seed_h)} \mathds{F}_2^n$ 
            \item Generate $(\mathbf{x, y}) \xleftarrow{\$} \mathds{F}_2^n$, with $\mathtt{wt}(\mathbf{x}) = \mathtt{wt}({\mathbf{y}}) = w$
            \item Calculate $\mathbf{s = x + hy}$
        \end{itemize}
        \begin{columns}
            \begin{column}{0.45\linewidth}
                \begin{center}
                    \textsf{pk} = $(\mathbf{h, s})$
                \end{center}
            \end{column}
            \begin{column}{0.45\linewidth}
                \begin{center}
                    \textsf{sk} = $(\mathbf{x, y})$
                \end{center}
            \end{column}
        \end{columns}
    \end{block}
\end{frame}

\begin{frame}{Public Key Encryption}
    To encrypt a message $\mathbf{m} \in \mathds{F}_2^k$ :
    \begin{block}{Encryption}
        \begin{itemize}
            \item Generate $(\mathbf{r_1, r_2}) \xleftarrow{\$} \mathds{F}_2^n$, with $\mathtt{wt}(\mathbf{r_1}) = \mathtt{wt}({\mathbf{r_2}}) = w_r$
            \item Generate $\mathbf{e} \xleftarrow{\$} \mathds{F}_2^n$, with $\mathtt{wt}(\mathbf{e}) = w_e$
            \item Calculate $\mathbf{u = r_1 + hr_2}$
            \item Calculate $\mathbf{v = mG +sr_2 + e}$
        \end{itemize}
        \begin{center}
            \textsf{ctx} = $(\mathbf{u, v})$
        \end{center}
    \end{block}
\end{frame}

\begin{frame}{Public Key Encryption}
    \begin{block}{Decryption}
        From the \textsf{ctx} = $(\mathbf{u, v})$ and the private key \textsf{pk} = $(\mathbf{x, y})$:
        \begin{equation*}
            \begin{aligned}
                \mathbf{v - u\cdot y} & \mathbf{ = (mG +s\cdot r_2 + e) - (r_1 + h\cdot r_2)y = mG + x\cdot r_2 -r_1\cdot y + e}\\
                &\mathbf{ = mG + (x + h\cdot y)r_2 + e - (r_1\cdot y  + h\cdot r_2\cdot y)}\\
                &\mathbf{ = mG + x\cdot r_2 + h\cdot y\cdot r_2 + e - r_1\cdot y - h\cdot r_2\cdot y}\\
                &\mathbf{ = mG + x_2 - r_1\cdot y + e}\\
            \end{aligned}
        \end{equation*}
        So we have $\mathbf{m} = \mathcal{C}.\textsf{Decode}(\mathbf{v - u\cdot y})$ whenever
        \begin{equation*}
            \mathtt{wt}(\mathbf{x\cdot r_2 - r_1\cdot y + e}) \leq \delta
        \end{equation*}
    \end{block}
\end{frame}

\begin{frame}{Key Encapsulation Mechanism}
    By applying the Fujisaki-Okamoto transformation it is possible to build a IND-CCA2 KEM.
    Let $\mathcal{G, H, K}$ be hash functions and $\mathcal{E}$ an instance of \textsf{HQC.PKE}
    \begin{block}{}
        \begin{itemize}
            \item \textbf{Setup}: generate the parameters $\lambda$ as in \textsf{HQC.PKE}, except that k will be the length of the key to be exchanged
            \item \textbf{KeyGen}: as in \textsf{HQC.PKE}
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Key Encapsulation Mechanism}
    Let $\mathcal{G, H, K}$ be hash functions and $\mathcal{E}$ an instance of \textsf{HQC.PKE}
    \begin{block}{Encapsulation}
        \begin{itemize}
            \item Generate the seed $\mathbf{m} \xleftarrow{\$} \mathds{F}_2^k$ and the randomness $\theta \leftarrow \mathcal{G}(\mathbf{m})$
            \item Generate the ciphertext $\mathbf{c} \leftarrow (\mathbf{u, v}) = \mathcal{E}.\textsf{Encrypt}(\textsf{pk}, \mathbf{m}, \theta)$
            \item Derive the symmetric key $K = \mathcal{K}(\mathbf{m, c})$
            \item Calculate $\mathbf{d} \leftarrow \mathcal{H}(\mathbf{m})$
            \item Send the pair $(\mathbf{c, d})$
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Key Encapsulation Mechanism}
    Let $\mathcal{G, H, K}$ be hash functions and $\mathcal{E}$ an instance of \textsf{HQC.PKE}
    \begin{block}{Decapsulation}
        \begin{itemize}
            \item Decrypt $\mathbf{m}^{'} \leftarrow \mathcal{E}.\textsf{Decrypt}(\textsf{sk}, \mathbf{c})$
            \item Compute $\theta^{'} \leftarrow \mathcal{G}(\mathbf{m}^{'})$ and $\mathbf{c}^{'} \leftarrow \mathcal{E}.\textsf{Encrypt}(\textsf{pk}, \mathbf{m}^{'}, \theta^{'})$
            \item Check that $\mathbf{c = c^{'}}$ and $\mathbf{d} = \mathcal{H}(\mathbf{m}^{'})$
            \item Derive the shared key $K \leftarrow \mathcal{K}(\mathbf{m, c})$
        \end{itemize}
    \end{block}
\end{frame}
